/*
Copyright 2025 Millstone HQ.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type KeyInitParameters struct {

	// A description of the key consisting of alphanumeric characters. Defaults to `""`.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Indicates if the key is ephemeral. Defaults to `false`.
	Ephemeral *bool `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// The expiry of the key in seconds. Defaults to `7776000` (90 days).
	Expiry *float64 `json:"expiry,omitempty" tf:"expiry,omitempty"`

	// Determines whether or not the machines authenticated by the key will be authorized for the tailnet by default. Defaults to `false`.
	Preauthorized *bool `json:"preauthorized,omitempty" tf:"preauthorized,omitempty"`

	// Determines whether the key should be created again if it becomes invalid. By default, reusable keys will be recreated, but single-use keys will not. Possible values: 'always', 'never'.
	RecreateIfInvalid *string `json:"recreateIfInvalid,omitempty" tf:"recreate_if_invalid,omitempty"`

	// Indicates if the key is reusable or single-use. Defaults to `false`.
	Reusable *bool `json:"reusable,omitempty" tf:"reusable,omitempty"`

	// List of tags to apply to the machines authenticated by the key.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// ID of the user who created this key, empty for keys created by OAuth clients.
	UserID *string `json:"userId,omitempty" tf:"user_id,omitempty"`
}

type KeyObservation struct {

	// The creation timestamp of the key in RFC3339 format
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// A description of the key consisting of alphanumeric characters. Defaults to `""`.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Indicates if the key is ephemeral. Defaults to `false`.
	Ephemeral *bool `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// The expiry timestamp of the key in RFC3339 format
	ExpiresAt *string `json:"expiresAt,omitempty" tf:"expires_at,omitempty"`

	// The expiry of the key in seconds. Defaults to `7776000` (90 days).
	Expiry *float64 `json:"expiry,omitempty" tf:"expiry,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Indicates whether the key is invalid (e.g. expired, revoked or has been deleted).
	Invalid *bool `json:"invalid,omitempty" tf:"invalid,omitempty"`

	// Determines whether or not the machines authenticated by the key will be authorized for the tailnet by default. Defaults to `false`.
	Preauthorized *bool `json:"preauthorized,omitempty" tf:"preauthorized,omitempty"`

	// Determines whether the key should be created again if it becomes invalid. By default, reusable keys will be recreated, but single-use keys will not. Possible values: 'always', 'never'.
	RecreateIfInvalid *string `json:"recreateIfInvalid,omitempty" tf:"recreate_if_invalid,omitempty"`

	// Indicates if the key is reusable or single-use. Defaults to `false`.
	Reusable *bool `json:"reusable,omitempty" tf:"reusable,omitempty"`

	// List of tags to apply to the machines authenticated by the key.
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// ID of the user who created this key, empty for keys created by OAuth clients.
	UserID *string `json:"userId,omitempty" tf:"user_id,omitempty"`
}

type KeyParameters struct {

	// A description of the key consisting of alphanumeric characters. Defaults to `""`.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Indicates if the key is ephemeral. Defaults to `false`.
	// +kubebuilder:validation:Optional
	Ephemeral *bool `json:"ephemeral,omitempty" tf:"ephemeral,omitempty"`

	// The expiry of the key in seconds. Defaults to `7776000` (90 days).
	// +kubebuilder:validation:Optional
	Expiry *float64 `json:"expiry,omitempty" tf:"expiry,omitempty"`

	// Determines whether or not the machines authenticated by the key will be authorized for the tailnet by default. Defaults to `false`.
	// +kubebuilder:validation:Optional
	Preauthorized *bool `json:"preauthorized,omitempty" tf:"preauthorized,omitempty"`

	// Determines whether the key should be created again if it becomes invalid. By default, reusable keys will be recreated, but single-use keys will not. Possible values: 'always', 'never'.
	// +kubebuilder:validation:Optional
	RecreateIfInvalid *string `json:"recreateIfInvalid,omitempty" tf:"recreate_if_invalid,omitempty"`

	// Indicates if the key is reusable or single-use. Defaults to `false`.
	// +kubebuilder:validation:Optional
	Reusable *bool `json:"reusable,omitempty" tf:"reusable,omitempty"`

	// List of tags to apply to the machines authenticated by the key.
	// +kubebuilder:validation:Optional
	// +listType=set
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// ID of the user who created this key, empty for keys created by OAuth clients.
	// +kubebuilder:validation:Optional
	UserID *string `json:"userId,omitempty" tf:"user_id,omitempty"`
}

// KeySpec defines the desired state of Key
type KeySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KeyParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KeyInitParameters `json:"initProvider,omitempty"`
}

// KeyStatus defines the observed state of Key.
type KeyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KeyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Key is the Schema for the Keys API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,tailscale}
type Key struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              KeySpec   `json:"spec"`
	Status            KeyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KeyList contains a list of Keys
type KeyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Key `json:"items"`
}

// Repository type metadata.
var (
	Key_Kind             = "Key"
	Key_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Key_Kind}.String()
	Key_KindAPIVersion   = Key_Kind + "." + CRDGroupVersion.String()
	Key_GroupVersionKind = CRDGroupVersion.WithKind(Key_Kind)
)

func init() {
	SchemeBuilder.Register(&Key{}, &KeyList{})
}
